---
vip: 5
title: Verida Personal Data Bridge
author: Chris Were <chris@verida.io>
discussions-to: #dev-blockchain on Verida Discord
status: Review
type: Standards Track
category: Extension
created: 2022-12-07
---

# Overview

A Verida extension will allow private off-chain data to be securely used within smart contracts in a cryptographically trusted manner.

# Use case examples

This will enable use cases such as:

1. A credit rating agency signing a credit score linked to a Verida identity (DID). The identity controller (end user) submits this credit score to a smart contract to access an under collatoralized loan.
2. A trusted entity signing a proof that a DID controls a social media account (ie: Facebook). The end user submits this social media ownership proof to a smart contract to mint a Soulbound token to a blockchain wallet the identity controls.
3. A trusted entity completes KYC verification of an end user and signs a message indicating the end user has passed KYC to generate a "KYC proof" associated with the user's DID. The end user submits this KYC proof to a smart contract in order to access a decentralized exchange that requires users to be KYC'd.

# Implementation

There are three concepts that must be implemented; off-chain data signing, smart contract data verification, smart contract request verification.

## Off-chain data signing

Off-chain data must be signed so it can be verified on-chain. This requires a signature scheme that can cheaply be executed on chain to verify signed data. We have chosen the default Ethereum signature scheme using `keccak256` hashing and `ed25519` signatures to maximise EVM compatibility. [Learn more](https://github.com/verida/did-server/blob/main/ARCHITECTURE.md#off-chain--on-chain-data-considerations).

This effectively allows any data to be signed by a Verida DID. This is implemented within the [keyring.sign(data: any)](https://github.com/verida/verida-js/blob/28d912bb27daa29f6718b440d6416f1d9d44e387/packages/keyring/src/keyring.ts#L109) method.

Verida supports identities (DID's) with an unlimited number of application contexts (`context`). You can think of a `context` like a container for the data of a given application. When a user signs into an application, they actually sign into a secure `context` that is isolated from other applications. Each of these `context`'s have their own signing keys which can be obtained from the `keyring` associated with the current `context`. As such, DID'd don't sign the data, a sub-key associated with a `context` actually signs the data.

### Verifying data signature

The data signature can be verified with [EncryptionUtils.verifySig(data, signature, publicKey)](https://github.com/verida/verida-js/blob/28d912bb27daa29f6718b440d6416f1d9d44e387/packages/encryption-utils/src/index.ts#L124):

- `data` - The original data that was signed
- `signature` - The signature generated by the DID `context` private signing key (via keyring.sign(data)[https://github.com/verida/verida-js/blob/28d912bb27daa29f6718b440d6416f1d9d44e387/packages/keyring/src/keyring.ts#L109])
- `publicKey` - The expected `context` public key. This can be found by resolving the DID Document and locating the signing public key at `doc.verificationMethod['${this.doc.id}?context=${contextHash}&type=sign]`.

You can easily do this **off-chain** if you fetch the signer's DID Document and then call `verifyContextSignature()`

```
import { DIDClient } from "@verida/did-client"
const didClient = new didClient({
    network: 'testnet'
})

// Fetch the DID Document
const did = 'did:vda:testnet:0x....'
const didDocument = await didClient.get(did)

// Verify the data was signed by the DID within a particular context
const data = "hello world"
const contextName = "My Test Application"
const signature = "..."

const isValid = didDocument.verifyContextSignature(data, contextName, signature)
```

## Smart contract data verification

It's necessary to support on-chain verification of data that provides the same functionality as `didDocument.verifyContextSignature()`, however we have limitations as a result of the smart contract environment. It's not possible to fetch a DID Document from the blockchain and it's too expensive to submit the full DID Document to the smart contract. The smart contract also needs to whitelist the DID's they trust to sign data.

We require a smart contract library that supports verifying any data with a trusted list of signing DIDs:

```
function verifyDataWithSigners(
        bytes memory data, 
        bytes memory signature,
        bytes memory proof,
        address[] memory validSigners
    ) internal virtual {...}
```

Where:

- `data` - The original data that was signed
- `signature` - The signature generated off-chain by the DID `context` private signing key (via keyring.sign(data)[https://github.com/verida/verida-js/blob/28d912bb27daa29f6718b440d6416f1d9d44e387/packages/keyring/src/keyring.ts#L109])
- `proof` - A signature generated off-chain by the DID controller showing it controls the public signing key
- `validSigners` - An array of DID's the smart contract will trust signed data from

The `data` and `signature` will be provided by the user of the smart contract (they will have stored this data off-chain and can submit it on-chain). The `validSigners` will be embedded into the smart contract. However, it's necessary to generate and verify the `proof` that demonstrates the signing DID controls the signing public key that actually signed the data.

### Proof generation

The `proof` is the signature generated by the DID controller private key signing the string:

 ```
 const proofString = `${didAddress}${contextSignPublicAddress}`.toLowerCase()
 const proof = EncryptionUtils.signData(proofString, didControllerPrivateKey)
 ```

 Where:

 - `didAddress` - The address portion of the DID (ie: `0x...` with `did:vda:testnet` removed)
 - `contextSignPublicAddress` - The address representation of the signing key (instead of the full public key) for increased efficiency on-chain
 - `didControllerPrivateKey` - The private key of the parent DID controller

This `proof` is automatically generated by the Verida DID Document library and stored in the `verificationMethod` of each application context. This is an extension to the DID-Core standard to support this cryptographically verifiable linkage.

### Locating the proof

The user submitting to the smart contract must first obtain the `proof` value from the DID that signed that data. It can fetch the DID Document and locate the proof string for the signing context:

```
// Fetch didDocument from '@verida/did-client' (as above)
// ...

// Locate the proof for a given context from the DID Document
const proof = didDocument.locateContextProof(contextName)
```

This `proof` string is submitted to the smart contract.

### Data verification

The public key that signed a piece of data can be recovered in the smart contract:

```
bytes32 dataHash = keccak256(data);
address contextSigner = ECDSAUpgradeable.recover(dataHash, signature);
```

Now we know the address of the signing key (`contextSigner`) that signed the data.

Next we need to verify the signing key is controlled by one of the `validSigners` (DID's) that is trusted by the smart contract.
  
### Proof verification

It's necessary to verify the `proof` proves one of the `validSigners` (DIDs) controls the `contextSigner` (public signing key).

We iterate through each `validSigners` and check if the combination of `contextSigner` and `validSigner` can recover the `validSigner` address from the `proof`:

```
 while (index < validSigners.length && !isVerified) {
    address account = validSigners[index];

    string memory strAccount = StringsUpgradeable.toHexString(uint256(uint160(account)));
    bytes memory proofString = abi.encodePacked(
        strAccount,
        strContextSigner
    );
    bytes32 proofHash = keccak256(proofString);
    address didSigner = ECDSAUpgradeable.recover(proofHash, proof);

    if (didSigner == account) {
        isVerified = true;
        break;
    }
    index++;
}
```

If the data verification and proof verifications pass, the data can be trusted within the smart contract.

## Smart contract request verification

Verida is designed to be multi-chain, so data is signed by a Verida DID key not a blockchain key. Public smart contract methods know the blockchain address that generated the request so can implicitly trust the request. However, the Verida protocol abstracts that, so we need a way to verify a given Verida DID has made a blockchain request.

It's necessary to ensure:

1. The request parameters have been signed by the DID (*)
2. The request is protected from replay attacks

(*) In reality, the request parameters must be signed by a `context` signing key controlled by the DID so that dApps can sign requests without access to the parent DID private key

We have just demonstrated the ability to verify any signed data on-chain, so we re-use that capability. The DID making the request signs the request data and submits to the smart contract:

- `did` - The DID that is generating the request
- `params` - The request parameters
- `signature` - The signed request parameters
- `proof` - The proof that demonstrates the `DID` controls the `context` signing key

We now need to prevent replay attacks. A malicious actor could observe the blockchain and replay a previous request. This isn't great if the request was to transfer tokens! A malicious user could repeat the transfer an unlimited number of times.

In order to protect from these replay attacks it's necessary to maintain a `nonce` value in the smart contract and have the user include the latest `nonce` value in the `params` that are signed. The smart contract must verify the signed `nonce` matches the latest `nonce` for the requesting DID stored in the smart contract.

# Multi-chain by design

One of the huge benefits of the Verida DID's not being linked to any particular blockchain, means this implementation can be replicated across any chain that supports `keccak256` hashing and `ed25519` signatures (basically every blockchain).

All that's required to support a new chain is to port the `VDAVerificationContract.sol` to the new chain and use it within smart contracts on that chain.

This also means that user's can have their data verified once and then use it across multiple smart contracts across multiple blockchains without having to re-verify their data.